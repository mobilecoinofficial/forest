import json
from typing import Optional
from forest.utils import logging

CLIENT = 'signal-cli' #get_secret("CLIENT")

RPC_CONFIG = json.loads('{ "signal-cli": { "request_obj": { "method": "str", "params": { "envelope": { "sourceNumber": "str", "sourceUuid": "str", "timestamp": "str", "dataMessage": { "message": "str", "expiresInSeconds": "int", "mentions": [ "str" ], "attachments": [ { "contentType": "str" }, { "filename": "str" }, { "id": "str" }, { "size": "int" } ], "groupInfo": { "groupId": "str", "type": "str" } }, "typingMessage": { "action": "str" }, "receiptMessage": { "when": "int", "isDelivery": "bool", "isRead": "bool", "timestamps": [ "int" ] } }, "error": { "message": "str", "type": "str" } } }, "error_obj": { "code": "int", "message": "str" }, "result_obj": { "timestamp": "int" } }, "signal-cli-metadata": { "message": "message", "groupId": "group", "attachments": "attachments", "dataMessage": "data_message", "typingMessage": "typing_notification", "receiptMessage": "receipt_notification", "error":"error" } }')
METADATA_CONFIG = RPC_CONFIG.get(CLIENT + "-metadata")

class Message:
    """ 
    Base message type 
    
    Attributes
    -----------
    blob: dict
       blob representing the jsonrpc message
    """
    def __init__(self, blob: dict) -> None:
        self.blob = blob

    def to_dict(self) -> dict:
        """
        Returns a dictionary of message instance 
        variables except for the blob
        """
        properties = {}
        for attr in dir(self):
            if not (attr.startswith("_") or attr == "blob"):
                val = getattr(self, attr)
                if val and not callable(val):
                    properties[attr] = val
        
        return properties

    def __getattr__(self, attr) -> None:
        # return falsy string back if not found
        return None
    
    def __repr__(self) -> str:
        return f"Message: {self.to_dict()}"
        
class JsonRPCMessageParser:
    """
    Provides methods to extract fields from a jsonrpc message (using 
    a pre-specified configuration) and classify what the message represents

    Attributes
    -----------
    config: dict
       configuration specifying schema of jsonrpc messages generated by the
       chosen signal client
    """
    def __init__(
            self, 
            config: dict = RPC_CONFIG.get(CLIENT),
            metadata_config: dict = METADATA_CONFIG
        ) -> None:
        logging.info(config) 
        self.config = config
        self.metadata_config = metadata_config
        if not self.metadata_config:
            logging.warning("No jsonrpc metadata specification found")

    def parse_message(self, 
            msg_contents: dict, 
            config: Optional[dict] = None,
            parsed_msg: Optional[dict] = None
            ) -> dict:
        """ 
        Selects attributes specified by a chosen configuration
        
        Parameters
        -----------
        msg_contents: dict
            jsonrpc formatted message
        config: dict
            desired schema configuration  
        parsed_msg: dict
            partially parsed message (if applicable)
            
        Returns
        ----------
        dict
            set of parameters to populate to the data message
            
        """
        if config is None:
            config = self.config
        if parsed_msg is None:
            parsed_msg = {} 
        
        for k in config.keys():
            logging.warning(k)
            data = msg_contents.get(k)
            if k not in msg_contents:
                data = msg_contents
            if isinstance(data, dict):
                if k in msg_contents and k not in ("params", "envelope"):
                    parsed_msg[k] = True
                if isinstance(config.get(k), dict):
                    self.parse_message(data, config.get(k), parsed_msg)
            elif (data or data == 0):
                parsed_msg[k] = data
        return parsed_msg

    def parse_metadata(self, 
            message_data, 
            metadata_config: Optional[dict] = None 
            ) -> tuple:
        """ 
        Looks for existing attributes in a message object and
        attempts to add metadata to identify the message's purpose

        Parameters
        -----------
        message: dict
            jsonrpc formatted message object
        metadata: dict
            metadata configuration

        Returns
        -----------
        tuple
            collection of metadata tags for use in msg class
        """ 
        metadata = []
        
        if message_data.get('type') == 'ProtocolInvalidMessageException':
            metadata.append('keystate_broken')

        if metadata_config is None:
            if not self.metadata_config:
                logging.warning("no metadata config found, \
                cannot set message metadata")
                return tuple(metadata)
            metadata_config = self.metadata_config
        
        for prop in message_data.keys():
            if prop in metadata_config:
                metadata.append(metadata_config.get(prop))
        
        return tuple(metadata)

    @staticmethod
    def jsonrpc_type(message: Message) -> str:
        """Determines what type of jsonrpc message was sent"""
        if message.blob.get("method"):
            return "request"
        if message.blob.get("error"):
            return "error"
        if message.blob.get("result"):
            return "response"
        return "invalid"


parser = JsonRPCMessageParser()
class JsonRpcMessage(Message):
    """ 
    jsonrpc message representation
    
    Attributes
    -----------
    blob: dict
       blob of information in json format
    """

    def __init__(self, blob: dict): 
        super().__init__(blob)
        
        # json rpc core data
        if blob.get("jsonrpc") != "2.0":
            raise ValueError("jsonrpc must be version 2.0")
        
        self.messagetype = parser.jsonrpc_type(self)
        self.jsonrpc = blob.get("jsonrpc")
        self.id = blob.get("id")
        msg_args = parser.parse_message(blob)
        for k,v in msg_args.items():
            setattr(self, k, v)
        self.metadata = parser.parse_metadata(self.to_dict())

class StdioMessage(Message):
    """Represents a Message received from signal-cli, optionally containing a command with arguments."""

    def __init__(self, blob: dict) -> None:
        super().__init__(blob)
        self.envelope = envelope = blob.get("envelope", {})
        # {'envelope': {'source': '+15133278483', 'sourceDevice': 2, 'timestamp': 1621402445257, 'receiptMessage': {'when': 1621402445257, 'isDelivery': True, 'isRead': False, 'timestamps': [1621402444517]}}}

        # envelope data
        self.source: str = envelope.get("source")
        self.name: str = envelope.get("sourceName") or self.source
        self.timestamp = envelope.get("timestamp")

        # msg data
        msg = envelope.get("dataMessage", {})
        self.full_text = self.text = msg.get("message", "")
        self.group: Optional[str] = msg.get("groupInfo", {}).get("groupId")
        self.quoted_text = msg.get("quote", {}).get("text")
        self.payment = msg.get("payment")

        # parsing
        self.command: Optional[str] = None
        self.tokens: Optional[list[str]] = None
        if self.text and self.text.startswith("/"):
            command, *self.tokens = self.text.split(" ")
            self.command = command[1:]  # remove /
            self.arg1 = self.tokens[0] if self.tokens else None
            self.text = " ".join(self.tokens)
        # self.reactions: dict[str, str] = {}

    def __repr__(self) -> str:
        # it might be nice to prune this so the logs are easier to read
        return f"<{self.envelope}>"

